<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Sales TV (Looker + Celebration)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000;
      font-family: Arial, sans-serif;
    }

    /* Two-frame double buffer */
    .frame {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      border: none;
      background: #000;

      opacity: 0;
      pointer-events: none;
      transition: opacity 220ms linear;
    }
    .frame.show {
      opacity: 1;
      pointer-events: auto;
    }

    /* Smooth loading overlay while next slide preloads */
    #loading {
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: 9000;
      display: none;
      align-items: center;
      justify-content: center;
      background: #000;
      color: #fff;
      font-size: 28px;
      letter-spacing: 0.5px;
    }
    #loading small {
      display: block;
      opacity: 0.65;
      margin-top: 10px;
      font-size: 18px;
    }

    /* Celebration overlay on top of everything */
    #celebration {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      z-index: 9999;
      background-repeat: no-repeat;
      background-position: center center;
      background-size: cover;
      color: #fff;
      text-align: center;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      padding: 60px 8vw;
      box-sizing: border-box;
    }

    #celebration h1 {
      font-size: 72px;
      margin: 0;
      text-shadow: 0 0 20px rgba(0,0,0,0.8);
      max-width: 1400px;
      margin-left: auto;
      margin-right: auto;
    }

    #celebration p {
      font-size: 32px;
      margin-top: 18px;
      max-width: 1400px;
      line-height: 1.3;
      white-space: pre-wrap;
      text-shadow: 0 0 15px rgba(0,0,0,0.8);
      margin-left: auto;
      margin-right: auto;
    }
  </style>
</head>

<body>

  <!-- Loading overlay (shows while next slide is warming up) -->
  <div id="loading">
    Loading next slideâ€¦
    <small>(This keeps transitions smooth on Fire TV)</small>
  </div>

  <!-- Celebration Overlay -->
  <div id="celebration">
    <h1 id="celeTitle">ðŸŽ‰ CELEBRATION ðŸŽ‰</h1>
    <p id="msg"></p>
  </div>

  <!-- Two iframes: one visible, one preloading next -->
  <iframe
    id="frameA"
    class="frame show"
    allow="fullscreen; autoplay; encrypted-media; picture-in-picture"
    referrerpolicy="no-referrer-when-downgrade"
  ></iframe>

  <iframe
    id="frameB"
    class="frame"
    allow="fullscreen; autoplay; encrypted-media; picture-in-picture"
    referrerpolicy="no-referrer-when-downgrade"
  ></iframe>

  <!-- Celebration Sounds -->
  <audio id="sound-idv" preload="auto">
    <source src="https://actions.google.com/sounds/v1/cash_register/cash_register_open.ogg" type="audio/ogg">
  </audio>

  <audio id="sound-tbk" preload="auto">
    <source src="https://actions.google.com/sounds/v1/crowd/crowd_cheer.ogg" type="audio/ogg">
  </audio>

  <script>
    /******************** LOOKER SLIDES ********************/
    const PAGES = [
      "https://lookerstudio.google.com/embed/reporting/8d1bd4f1-48eb-4ab3-a749-20fb4f0cbc1a/page/kMFmF",
      "https://lookerstudio.google.com/embed/reporting/8d1bd4f1-48eb-4ab3-a749-20fb4f0cbc1a/page/p_9j0kd2f9zd",
      "https://lookerstudio.google.com/embed/reporting/8d1bd4f1-48eb-4ab3-a749-20fb4f0cbc1a/page/p_mql5w6hc0d",
      "https://lookerstudio.google.com/embed/reporting/8d1bd4f1-48eb-4ab3-a749-20fb4f0cbc1a/page/p_dl20oeic0d",
      "https://lookerstudio.google.com/embed/reporting/8d1bd4f1-48eb-4ab3-a749-20fb4f0cbc1a/page/p_pnjbc5kc0d",
      "https://lookerstudio.google.com/embed/reporting/8d1bd4f1-48eb-4ab3-a749-20fb4f0cbc1a/page/p_3pifgdlc0d",
      "https://lookerstudio.google.com/embed/reporting/8d1bd4f1-48eb-4ab3-a749-20fb4f0cbc1a/page/p_i1q8nglc0d"
    ];

    // Slide duration (you can increase this if Looker is heavy)
    const SLIDE_MS = 150000; // 2m30s

    // Start preloading the next slide after this fraction of the current slide has been shown
    // (preload earlier = smoother switches)
    const PRELOAD_AT_FRACTION = 0.45; // 45% into the slide

    // IMPORTANT: don't cache-bust every switch; bucket it (big speedup).
    // Set to 2-5 minutes. This still updates many times/day but avoids constant cold loads.
    const CACHE_WINDOW_MS = 3 * 60 * 1000; // 3 minutes

    // If the next slide takes too long to load, we still switch after this time (fallback)
    const MAX_PRELOAD_WAIT_MS = 45000; // 45s

    function cacheToken() {
      return Math.floor(Date.now() / CACHE_WINDOW_MS);
    }
    function withCache(url) {
      const sep = url.includes("?") ? "&" : "?";
      return url + sep + "cb=" + cacheToken();
    }

    const loadingEl = document.getElementById("loading");
    function showLoading(v) {
      if (isCelebrationVisible()) return;
      loadingEl.style.display = v ? "flex" : "none";
    }

    const frameA = document.getElementById("frameA");
    const frameB = document.getElementById("frameB");

    let current = 0;          // currently visible slide index
    let activeIsA = true;     // true => A visible; false => B visible
    let preloadTimer = null;
    let rotateTimer = null;

    function activeFrame() { return activeIsA ? frameA : frameB; }
    function hiddenFrame() { return activeIsA ? frameB : frameA; }

    function setVisible(isA) {
      activeIsA = isA;
      frameA.classList.toggle("show", activeIsA);
      frameB.classList.toggle("show", !activeIsA);
    }

    function isIframeLoadedEnough(frame) {
      // Cross-origin: we can't inspect content. Best we can do is rely on onload events.
      // So this function is intentionally minimal.
      return true;
    }

    function loadInto(frame, pageIndex, onDone) {
      frame.onload = null;
      frame.src = withCache(PAGES[pageIndex]);
      frame.onload = () => onDone && onDone();
    }

    // Preload logic: start preloading next slide in hidden frame,
    // then at switch time we usually just flip instantly.
    let nextIndex = 1;
    let nextReady = false;
    let nextLoadStartedAt = 0;
    let nextLoadTimeout = null;

    function startPreloadNext() {
      if (isCelebrationVisible()) return;

      nextIndex = (current + 1) % PAGES.length;
      nextReady = false;
      nextLoadStartedAt = Date.now();

      const hidden = hiddenFrame();
      loadInto(hidden, nextIndex, () => {
        nextReady = true;
        // If we're already at/after switch time, swap immediately
      });

      // Fallback: if Looker never fires load (or is super slow), allow swap anyway after a max wait
      clearTimeout(nextLoadTimeout);
      nextLoadTimeout = setTimeout(() => {
        nextReady = true; // allow swap even if not fully loaded
      }, MAX_PRELOAD_WAIT_MS);
    }

    function schedulePreloadAndRotate() {
      clearTimeout(preloadTimer);
      clearTimeout(rotateTimer);

      // Start preloading after a portion of SLIDE_MS
      preloadTimer = setTimeout(() => {
        startPreloadNext();
      }, Math.floor(SLIDE_MS * PRELOAD_AT_FRACTION));

      // Rotate at SLIDE_MS (swap to preloaded slide)
      rotateTimer = setTimeout(() => {
        rotateToNextSmooth();
      }, SLIDE_MS);
    }

    function rotateToNextSmooth() {
      if (isCelebrationVisible()) {
        // If a celebration is on, postpone a bit and try again
        rotateTimer = setTimeout(rotateToNextSmooth, 1500);
        return;
      }

      // If preload hasn't been started yet (e.g., short slide), start now
      if (!nextLoadStartedAt || nextIndex !== (current + 1) % PAGES.length) {
        startPreloadNext();
      }

      // If not ready yet, show a clean loading overlay instead of showing Lookerâ€™s loading between frames
      const waitStart = Date.now();

      const trySwap = () => {
        if (isCelebrationVisible()) return;

        if (nextReady) {
          showLoading(false);
          current = nextIndex;
          setVisible(!activeIsA);  // hidden becomes visible
          // Immediately schedule next preload/switch
          schedulePreloadAndRotate();
          return;
        }

        // Not ready yet â€” keep overlay, check again shortly
        showLoading(true);

        // Safety: if we've waited too long, force swap anyway (overlay still hides the worst)
        if (Date.now() - waitStart > MAX_PRELOAD_WAIT_MS) {
          nextReady = true;
        }

        setTimeout(trySwap, 250);
      };

      trySwap();
    }

    // Initial boot: load slide 0 into A, then schedule preload/switch
    loadInto(frameA, 0, () => {
      setVisible(true);
      schedulePreloadAndRotate();
      // Start the first preload sooner for smoother first transition
      setTimeout(startPreloadNext, 3000);
    });

    /******************** CELEBRATIONS ********************/
    const triggerUrl = "https://script.google.com/macros/s/AKfycbwPFEP8tWC85Xo5RVvjwNvMXSI-W6iqcIvnCfKIpJrehVX-X6jEfaqDkFR_dWTB_ApduA/exec";
    const POLL_MS = 2000;

    const CELEBRATIONS = {
      IDV: {
        title: "ðŸŽ‰ NEW IDV ðŸŽ‰",
        gif: "https://media.giphy.com/media/Is1O1TWV0LEJi/giphy.gif",
        sound: document.getElementById("sound-idv")
      },
      TBK: {
        title: "ðŸ† NEW TBK ðŸ†",
        gif: "https://media.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif",
        sound: document.getElementById("sound-tbk")
      }
    };

    const celebrationEl = document.getElementById("celebration");
    const titleEl = document.getElementById("celeTitle");
    const msgEl = document.getElementById("msg");

    let overlayVisible = false;
    let currentCelebrationKey = null;

    function showOverlay(kindKey, message) {
      const cfg = CELEBRATIONS[kindKey];
      if (!cfg) return;

      // Hide loading overlay if celebration comes in
      showLoading(false);

      if (currentCelebrationKey !== kindKey) {
        titleEl.textContent = cfg.title;
        celebrationEl.style.backgroundImage =
          `linear-gradient(rgba(0,0,0,0.25), rgba(0,0,0,0.25)), url("${cfg.gif}")`;
        currentCelebrationKey = kindKey;
      }

      msgEl.innerText = message || "";

      if (!overlayVisible && cfg.sound) {
        try {
          cfg.sound.currentTime = 0;
          cfg.sound.play();
        } catch (e) {
          console.log("Audio autoplay blocked");
        }
      }

      celebrationEl.style.display = "flex";
      overlayVisible = true;
    }

    function hideOverlay() {
      celebrationEl.style.display = "none";
      msgEl.innerText = "";
      overlayVisible = false;
      currentCelebrationKey = null;
    }

    function isCelebrationVisible() {
      return celebrationEl.style.display === "flex";
    }

    function normUpper(v){ return (v ?? "").toString().trim().toUpperCase(); }
    function norm(v){ return (v ?? "").toString().trim(); }

    async function poll() {
      try {
        const res = await fetch(triggerUrl + "?cb=" + Date.now(), { cache: "no-store" });
        const data = await res.json();
        const status = normUpper(data.status);
        const message = norm(data.message);

        if (CELEBRATIONS[status]) showOverlay(status, message);
        else if (overlayVisible) hideOverlay();
      } catch (e) {
        console.error(e);
      }
    }

    poll();
    setInterval(poll, POLL_MS);

    // One-time audio unlock after any user interaction
    function unlockAudio() {
      const sounds = document.querySelectorAll("audio");
      sounds.forEach(a => {
        const prevVol = a.volume;
        a.volume = 0;
        a.play().then(() => {
          a.pause();
          a.currentTime = 0;
          a.volume = prevVol;
        }).catch(() => {});
      });

      window.removeEventListener("pointerdown", unlockAudio);
      window.removeEventListener("keydown", unlockAudio);
    }
    window.addEventListener("pointerdown", unlockAudio, { once: true });
    window.addEventListener("keydown", unlockAudio, { once: true });

    // Optional: if Fire TV gets weird after long uptime, reload the whole page occasionally
    // setInterval(() => location.reload(), 6 * 60 * 60 * 1000); // every 6 hours
  </script>
</body>
</html>
